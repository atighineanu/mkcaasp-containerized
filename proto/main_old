package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/md5"
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strings"
)

type OSAPI struct {
	AuthURL            string
	RegionName         string
	ProjectName        string
	UserDomainName     string
	IdentityAPIVersion string
	Interface          string
	Username           string
	Password           []byte
	ProjectID          string
}

func Hashinator(pass string, homedir string, caasporsespdir string) {
	v := OSAPI{}
	var tempkey string
	file, _ := os.Open(homedir + "/key.json")
	decoder := json.NewDecoder(file)
	defer file.Close()
	err := decoder.Decode(&tempkey)
	if err != nil {
		fmt.Println("This is bad! .json decoding didn't work:", err)
	}

	file, _ = os.Open(homedir + caasporsespdir + "/openstack.json")
	decoder = json.NewDecoder(file)
	defer file.Close()
	err = decoder.Decode(&v)
	if err != nil {
		fmt.Println("This is bad! .json decoding didn't work:", err)
	}
	block, _ := aes.NewCipher([]byte(Hasher(tempkey)))
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		panic(err.Error())
	}
	nonce := make([]byte, gcm.NonceSize())
	if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
		panic(err.Error())
	}
	ciphertext := gcm.Seal(nonce, nonce, []byte(pass), nil)
	f, err := ioutil.ReadFile(homedir + caasporsespdir + "/openstack.json")
	if err != nil {
		fmt.Printf("Error at opening json file!...%s")
	}
	v.Password = ciphertext[:]
	f, _ = json.MarshalIndent(v, "", " ")
	err = ioutil.WriteFile(homedir+caasporsespdir+"/openstack.json", f, 0644)
	if err != nil {
		fmt.Printf("Error at writing to json file!...%s")
	}
}

func Dehashinator(homedir string, caasporsespdir string) string {

	v := OSAPI{}
	file, _ := os.Open(homedir + caasporsespdir + "/openstack.json")
	decoder := json.NewDecoder(file)
	defer file.Close()
	err := decoder.Decode(&v)
	if err != nil {
		fmt.Println("This is bad! .json decoding didn't work:", err)
	}

	var tempkey string
	file, _ = os.Open(homedir + "/key.json")
	decoder = json.NewDecoder(file)
	defer file.Close()
	err = decoder.Decode(&tempkey)
	if err != nil {
		fmt.Println("This is bad! .json decoding didn't work:", err)
	}

	block, err := aes.NewCipher([]byte(Hasher(tempkey)))
	if err != nil {
		panic(err.Error())
	}
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		panic(err.Error())
	}
	nonceSize := gcm.NonceSize()
	nonce, ciphertext := v.Password[:nonceSize], v.Password[nonceSize:]
	decoded, err := gcm.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		panic(err.Error())
	}
	return string(decoded)
}

func Hasher(key string) string {
	hasher := md5.New()
	hasher.Write([]byte(key))
	return hex.EncodeToString(hasher.Sum(nil))
}

var (
	append = flag.String("addnodes", "", "how many more nodes to add, usage m2w2 -2 more masters, 2 more workers")
	hash   = flag.String("key", "default", "apashe")
	pass   = flag.String("pass", "password", "apda")
)

var CulsterTempl = `image_name = "SUSE-CaaS-Platform-3.0-for-OpenStack-Cloud.x86_64-3.0.0-GM.qcow2"
					internal_net = "INGSOC-net"
					external_net = "floating"
					admin_size = "m1.large"
					master_size = "m1.medium"
					masters = {{.MastersCount}}
					worker_size = "m1.medium"
					workers = {{.WorkersCount}}
					workers_vol_enabled = 0
					workers_vol_size = 5
					dnsdomain = "testing.qa.caasp.suse.net"
					dnsentry = 0
					stack_name = "INGSOC"`
var nodes struct {
	MastersCount int64
	WorkersCount int64
}

func main() {
	flag.Parse()

	if *pass != "default" {
		out, err := exec.Command("ls", "-alh").CombinedOutput()
		if err != nil {
			log.Fatalf("couldn't exec the command...%s", err)
		}
		if strings.Contains(fmt.Sprintf("%s", string(out)), "key.json") && !strings.Contains(*hash, "default") {
			f, err := os.Create("key.json")
			if err != nil {
				log.Fatalf("couldn't create the file...%s", err)
			}
			f.Write([]byte(*hash))
			f.Close()
		}
		out, err = exec.Command("cat", "key.json").CombinedOutput()
		if err != nil {
			log.Fatalf("couldn't exec the command...%s", err)
		}
		fmt.Println(fmt.Sprintf("%s", string(out)))
	}

	//fmt.Println(Dehasher("/home/atighineanu/work/CaaSP_kube/automation/caasp-openstack-terraform"))
	//Hashinator("agkjsgknksksg", ".", "")
	//fmt.Println(Dehashinator(".", ""))
	//dir, err := filepath.Abs(filepath.Dir(os.Args[1]))
	//if err != nil {
	//	log.Fatal(err)
	//}
	//fmt.Println(dir)
	/*	flag.Parse()
		if *append != "" {
			temp := strings.Split(*append, "")
			fmt.Println(temp)
			if len(temp) > 4 {
				log.Fatalf("Check your syntaxis...there must be just four symbols in -addnodes argument")
			} else {
				for i := 0; i < len(temp); i++ {
					if temp[i] == "w" {
						if len(temp) >= i+2 {
							//fmt.Printf("there are %s workers.\n", temp[i+1])
							nodes.WorkersCount, _ = strconv.ParseInt(temp[i+1], 10, 32)
							fmt.Printf("Adding %v workers.\n", nodes.WorkersCount)
						}
					}
					if temp[i] == "m" {
						if len(temp) >= i+2 {
							//fmt.Printf("there are %s masters.\n", temp[i+1])
							nodes.MastersCount, _ = strconv.ParseInt(temp[i+1], 10, 32)
							fmt.Printf("Adding %v masters.\n", nodes.MastersCount)
						}
					}
				}
			}
		}

		if nodes.MastersCount > 0 || nodes.WorkersCount > 0 {
			nodes.MastersCount += 1 //by default there was 1 master
			nodes.WorkersCount += 2 //by default there were 2 workers
			templ, err := template.New("AddingNodes").Parse(CulsterTempl)
			if err != nil {
				log.Fatalf("Search didn't work...%s", err)
			}
			var f *os.File
			f, err = os.Create("tf.tfvars")
			if err != nil {
				log.Fatalf("couldn't create the file...%s", err)
			}
			err = templ.Execute(f, nodes)
			if err != nil {
				fmt.Printf("%s", err)
			}
			f.Close()
		}*/
}
